// Code generated by fw from github.com/Jiang-Gianni/fw
// NOTE: any update will be overridden after regenerating the file with the fw command.

package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"slices"
	"strings"
	"time"

	"github.com/andybalholm/brotli"
	"github.com/evanw/esbuild/pkg/api"
	"github.com/fsnotify/fsnotify"
)

type FW struct {
	name            string
	files           []string
	regexMatch      *regexp.Regexp
	run             RunFunc
	previousRunTime time.Time
}

type RunFunc func(e fsnotify.Event)

var (
	directoriesToWatch = []string{"."}
	cooldownDuration   = time.Millisecond * 500
)

var fws = []*FW{
	{
		name:       "go main",
		regexMatch: regexp.MustCompile(`main\/.*.go$`),
		run: func() RunFunc {
			var (
				ctx    context.Context
				cancel context.CancelFunc
			)
			go func() {
				for {
					ctx, cancel = context.WithCancel(context.TODO())
					cmd := exec.CommandContext(ctx, "make", "run")
					go RunCmd(cmd)
					<-ctx.Done()
				}
			}()
			return func(e fsnotify.Event) {
				RunCmd(exec.Command("fuser", "-k", "3000/tcp"))
				cancel()
			}
		}(),
	},
	{
		// https://github.com/sqlc-dev/sqlc
		name:       "sqlc generate",
		regexMatch: regexp.MustCompile(`.*.sql$`),
		run: func(e fsnotify.Event) {
			RunCmd(exec.Command("sqlc", "generate"))
		},
	},
	{
		// https://github.com/a-h/templ
		name:       "templ",
		regexMatch: regexp.MustCompile(`main\/.*.templ$`),
		run: func(e fsnotify.Event) {
			RunCmd(exec.Command("templ", "generate", "-lazy", "-v"))
			RunCmd(exec.Command("templ", "fmt", "."))
		},
	},
	{
		// https://github.com/evanw/esbuild
		name:       "esbuild",
		regexMatch: regexp.MustCompile(`browser\/.*.ts$`),
		run:        esbuildFunc(),
	},
	{
		// https://github.com/andybalholm/brotli
		name:       "brotli",
		regexMatch: regexp.MustCompile(`main\/assets\/.*`),
		run:        brotliFunc(),
	},
	{
		// https://github.com/bufbuild/buf
		name:       "buf",
		regexMatch: regexp.MustCompile(`/*.proto$`),
		run: func(e fsnotify.Event) {
			RunCmd(exec.Command("buf", "generate"))
		},
	},
	// {
	// 	// https://github.com/yuin/goldmark
	// 	name:       "markdown",
	// 	regexMatch: regexp.MustCompile(`/*.md$`),
	// 	run:        markdownFunc(),
	// },
}

func main() {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer closeFunc(watcher)

	for _, dir := range directoriesToWatch {
		err = AddDir(dir, watcher)
		if err != nil {
			log.Fatal(err)
		}
	}

	for event := range watcher.Events {
		for _, fw := range fws {
			if time.Since(fw.previousRunTime) < cooldownDuration {
				continue
			}
			if (len(fw.files) > 0 && slices.Contains(fw.files, event.Name)) ||
				(fw.regexMatch != nil && fw.regexMatch.MatchString(event.Name)) {
				fw.previousRunTime = time.Now()
				log.Println("running: ", fw.name)

				/*
					sometimes the event is triggered multiple times for the same file
					with empty/invalid contents (or maybe file reading issue) on the first trigger
				*/
				time.Sleep(time.Millisecond * 10)

				fw.run(event)
			}
		}
	}
}

func RunCmd(cmd *exec.Cmd) {
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		log.Printf("cmd.Run: %v\n", err)
	}
}

func AddDir(dir string, watcher *fsnotify.Watcher) error {
	err := watcher.Add(dir)
	if err != nil {
		return fmt.Errorf("watcher.Add[%T]: %w", err, err)
	}
	entries, err := os.ReadDir(dir)
	if err != nil {
		return fmt.Errorf("os.ReadDir[%T]: %w", err, err)
	}

	for _, entry := range entries {
		if !entry.IsDir() || entry.Name() == ".git" {
			continue
		}
		entryName := dir + "/" + entry.Name()
		if dir == "./" {
			entryName = "./" + entry.Name()
		}
		AddDir(entryName, watcher)
	}
	return nil
}

func esbuildFunc() RunFunc {
	opts := api.BuildOptions{
		EntryPointsAdvanced: []api.EntryPoint{
			{
				InputPath: "browser/index.ts",
			},
		},
		Bundle:            true,
		Format:            api.FormatESModule,
		LogLevel:          api.LogLevelInfo,
		MinifyIdentifiers: true,
		MinifySyntax:      true,
		MinifyWhitespace:  true,
		Outfile:           "main/assets/zhteuern.js",
		Sourcemap:         api.SourceMapLinked,
		Target:            api.ESNext,
		Write:             true,
	}

	return func(e fsnotify.Event) {
		result := api.Build(opts)
		for _, message := range result.Errors {
			fmt.Printf("%+v", message)
		}
	}
}

func brotliFunc() RunFunc {
	return func(e fsnotify.Event) {
		defer httpRequestFunc()
		outFilename := strings.ReplaceAll(e.Name, "main/assets", "main/brotli")
		outFile, err := os.Create(outFilename)
		if err != nil {
			log.Printf("os.Create[%T]: %v\n", err, err)
			return
		}
		defer closeFunc(outFile)

		fileBytes, err := os.ReadFile(e.Name)
		if err != nil {
			log.Printf("os.ReadFile[%T]: %v\n", err, err)
			return
		}

		b := brotli.NewWriterLevel(outFile, brotli.BestCompression)
		defer closeFunc(b)
		defer flushFunc(b)
		_, err = b.Write(fileBytes)
		if err != nil {
			log.Printf("brotli.Write[%T]: %v\n", err, err)
		}
	}
}

func closeFunc(c io.Closer) {
	if err := c.Close(); err != nil {
		log.Printf("close[%T]: %v\n", err, err)
	}
}

func flushFunc(f interface{ Flush() error }) {
	if err := f.Flush(); err != nil {
		log.Printf("flush[%T]: %v\n", err, err)
	}
}

// func markdownFunc() RunFunc {
// 	var markdown = goldmark.New(
// 		goldmark.WithRendererOptions(
// 			html.WithUnsafe(),
// 		),
// 		goldmark.WithExtensions(
// 			extension.GFM,
// 			highlighting.NewHighlighting(
// 				highlighting.WithStyle("hrdark"),
// 				highlighting.WithFormatOptions(),
// 			),
// 		),
// 	)
// 	return func(e fsnotify.Event) {
// 		htmlFilename := e.Name + ".html"
// 		defer func() {
// 			select {
// 			case startGo <- struct{}{}:
// 			default:
// 			}
// 		}()

// 		fileBytes, err := os.ReadFile(e.Name)
// 		if err != nil {
// 			log.Printf("os.ReadFile[%T]: %v\n", err, err)
// 			return
// 		}

// 		outFile, err := os.Create(htmlFilename)
// 		if err != nil {
// 			log.Printf("os.Create[%T]: %v\n", err, err)
// 			return
// 		}
// 		defer closeFunc(outFile)

// 		if err := markdown.Convert(fileBytes, outFile); err != nil {
// 			log.Printf("markdown.Convert[%T]: %v\n", err, err)
// 			return
// 		}
// 	}
// }

func httpRequestFunc() {
	client := &http.Client{}
	req, err := http.NewRequest(
		http.MethodPatch,
		"http://localhost:3000/hot",
		nil,
	)
	if err != nil {
		log.Printf("http.NewRequest[%T]: %v\n", err, err)
	}
	req.Header.Set("Sec-Fetch-Mode", "cors")
	req.Header.Set("Sec-Fetch-Site", "same-origin")
	req.Header.Set("Force", "true")
	_, err = client.Do(req)
	if err != nil {
		log.Printf("http.Patch[%T]: %v\n", err, err)
	}
}
